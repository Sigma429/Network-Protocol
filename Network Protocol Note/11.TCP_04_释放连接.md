## 释放连接

### 1.概述



![image-20230930163451039](imgs\image-20230930163451039.png)

### 2.状态解读

FIN-WAIT-1状态是主动方发送FIN=1

![image-20230930163957505](imgs\image-20230930163957505.png)

 三次挥手的情况下，第二次挥手和第三次挥手合并，在FIN-WAIT-1状态下直接进入TIME-WAIT状态

![image-20230930170723060](imgs\image-20230930170723060.png)



![image-20230930170106097](imgs\image-20230930170106097.png)

### 3.细节

TIME-WAIT用来等对方的FIN，因为如果对方没收到ACK，会重发FIN

在等待时间内没收到对方的FIN，说明对方收到了ACK

如果在等待时间内又收到对方的FIN，说明对方没收到ACK，会重新发ACK

防止本次连接中产生的数据包误传到下一次连接中，第二次和第三次挥手之间，如果服务器端有数据，会发过来。如果没有TIME-WAIT阶段，本次连接中产生的数据包就有可能会误传到下一次连接中（client有个新的程序刚好分配了同一个端口）

第三次挥手发过来，第四次挥手发过去的时间为2倍的MSL，因此本次连接中的数据包都会在2MSL时间内消失

![image-20230930210604888](imgs\image-20230930210604888.png)

### 4.疑问

#### 4.1 4次挥手的原因

![image-20230930164307589](imgs\image-20230930164307589.png)

#### 4.2 长连接和短连接

区分：做完数据交互后，是否马上关闭连接（数据交互方式）

客户端发送数据，创建连接，发送完数据后直接四次挥手关闭连接，可称为短连接

客户端创建连接后，不断开，可以一直发送数据，为长连接（适合频繁数据交互的），长连接的释放取决于代码

![image-20230930213603891](imgs\image-20230930213603891.png)

![image-20230930214518523](imgs\image-20230930214518523.png)

#### 4.3

建立连接后，不断开连接，内存中的两个socket对象保留，只是数据交互时，数据都途径网卡，不会对网卡有影响

#### 4.4 

假设数据太多，网卡接收不过来数据，直接丢弃，这个时候数据是不是只传到了物理层，但是上不到数据链路层？

 网卡是工作在数据链路层的，要检查目标Mac地址是否正确

数据链路层的缓冲区满了，数据都被网卡给扔了，其实已经到了数据链路层

![image-20230930222453077](imgs\image-20230930222453077.png)

### 5.抓包

Wireshark  以太网是监听网卡

Adapter for loopback traffic capture 用于监听本地发给本地的数据

![image-20230930173501058](imgs\image-20230930173501058.png)

客户端想关闭连接，但不影响服务器返回数据给客户端（如下图），关闭是双向的

Java写的客户端直接关闭连接，只会发一条RST请求来断开连接

![image-20230930193917621](imgs\image-20230930193917621.png)



建立连接后，默认情况下，服务器会一直等待，但有的服务器会设置成，等待多长时间后，仍未收到数据，会主动发FIN断开连接

为避免该情况，客户端每隔一段时间发送数据包（保活）（心跳包）

让服务器一直等待并不好，万一客户端真的关闭了，会浪费资源，可以在应用层搞个定时器，每隔15s检测是否有数据包发过来

（开发可以在应用层主动实现）

![image-20230930194939491](imgs\image-20230930194939491.png)



### 6.三次挥手



![image-20230930203001276](imgs\image-20230930203001276.png)

